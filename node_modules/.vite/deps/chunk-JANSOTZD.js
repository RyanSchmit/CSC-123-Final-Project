var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/clone/clone.js"(exports, module) {
    var clone = function() {
      "use strict";
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve, reject) {
              parent2.then(function(value) {
                resolve(_clone(value, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex)
              child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value, key2) {
              var keyChild = _clone(key2, depth2 - 1);
              var valueChild = _clone(value, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value) {
              var entryChild = _clone(value, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i = 0; i < symbols.length; i++) {
              var symbol = symbols[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i = 0; i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c = function() {
        };
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global)
          flags += "g";
        if (re.ignoreCase)
          flags += "i";
        if (re.multiline)
          flags += "m";
        return flags;
      }
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module === "object" && module.exports) {
      module.exports = clone;
    }
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys2;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys2 = Object.keys(a);
        length = keys2.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key2 = keys2[i];
          if (!equal(a[key2], b[key2]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify2(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify2(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys2 = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys2.length; i++) {
          var key2 = keys2[i];
          var value = stringify2(node[key2]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key2) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// node_modules/vega-lite/build/src/util.js
var import_clone = __toESM(require_clone());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify());

// node_modules/vega-util/build/vega-util.module.js
function accessor(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}
function getter(path) {
  return path.length === 1 ? get1(path[0]) : getN(path);
}
var get1 = (field2) => function(obj) {
  return obj[field2];
};
var getN = (path) => {
  const len = path.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path[i]];
    }
    return obj;
  };
};
function error(message) {
  throw Error(message);
}
function splitAccessPath(p) {
  const path = [], n = p.length;
  let q = null, b = 0, s = "", i, j, c;
  p = p + "";
  function push() {
    path.push(s + p.substring(i, j));
    s = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c = p[j];
    if (c === "\\") {
      s += p.substring(i, j);
      s += p.substring(++j, ++j);
      i = j;
    } else if (c === q) {
      push();
      q = null;
      b = -1;
    } else if (q) {
      continue;
    } else if (i === b && c === '"') {
      i = j + 1;
      q = c;
    } else if (i === b && c === "'") {
      i = j + 1;
      q = c;
    } else if (c === "." && !b) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c === "[") {
      if (j > i)
        push();
      b = i = j + 1;
    } else if (c === "]") {
      if (!b)
        error("Access path missing open bracket: " + p);
      if (b > 0)
        push();
      b = 0;
      i = j + 1;
    }
  }
  if (b)
    error("Access path missing closing bracket: " + p);
  if (q)
    error("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path;
}
function field(field2, name, opt) {
  const path = splitAccessPath(field2);
  field2 = path.length === 1 ? path[0] : field2;
  return accessor((opt && opt.get || getter)(path), [field2], name || field2);
}
var id = field("id");
var identity = accessor((_) => _, [], "identity");
var zero = accessor(() => 0, [], "zero");
var one = accessor(() => 1, [], "one");
var truthy = accessor(() => true, [], "true");
var falsy = accessor(() => false, [], "false");
function log$1(method, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method].apply(console, args);
}
var None = 0;
var Error$1 = 1;
var Warn = 2;
var Info = 3;
var Debug = 4;
function logger(_, method, handler = log$1) {
  let level = _ || None;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$1)
        handler(method || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn)
        handler(method || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info)
        handler(method || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug)
        handler(method || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var isArray = Array.isArray;
function isObject(_) {
  return _ === Object(_);
}
var isLegalKey = (key2) => key2 !== "__proto__";
function mergeConfig(...configs) {
  return configs.reduce((out, source) => {
    for (const key2 in source) {
      if (key2 === "signals") {
        out.signals = mergeNamed(out.signals, source.signals);
      } else {
        const r = key2 === "legend" ? {
          layout: 1
        } : key2 === "style" ? true : null;
        writeConfig(out, key2, source[key2], r);
      }
    }
    return out;
  }, {});
}
function writeConfig(output, key2, value, recurse) {
  if (!isLegalKey(key2))
    return;
  let k, o;
  if (isObject(value) && !isArray(value)) {
    o = isObject(output[key2]) ? output[key2] : output[key2] = {};
    for (k in value) {
      if (recurse && (recurse === true || recurse[k])) {
        writeConfig(o, k, value[k]);
      } else if (isLegalKey(k)) {
        o[k] = value[k];
      }
    }
  } else {
    output[key2] = value;
  }
}
function mergeNamed(a, b) {
  if (a == null)
    return b;
  const map = {}, out = [];
  function add(_) {
    if (!map[_.name]) {
      map[_.name] = 1;
      out.push(_);
    }
  }
  b.forEach(add);
  a.forEach(add);
  return out;
}
function peek(array2) {
  return array2[array2.length - 1];
}
function toNumber(_) {
  return _ == null || _ === "" ? null : +_;
}
var exp = (sign) => (x) => sign * Math.exp(x);
var log = (sign) => (x) => Math.log(sign * x);
var symlog = (c) => (x) => Math.sign(x) * Math.log1p(Math.abs(x / c));
var symexp = (c) => (x) => Math.sign(x) * Math.expm1(Math.abs(x)) * c;
var pow = (exponent) => (x) => x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
function pan(domain, delta, lift, ground) {
  const d0 = lift(domain[0]), d1 = lift(peek(domain)), dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear(domain, delta) {
  return pan(domain, delta, toNumber, identity);
}
function panLog(domain, delta) {
  var sign = Math.sign(domain[0]);
  return pan(domain, delta, log(sign), exp(sign));
}
function panPow(domain, delta, exponent) {
  return pan(domain, delta, pow(exponent), pow(1 / exponent));
}
function panSymlog(domain, delta, constant2) {
  return pan(domain, delta, symlog(constant2), symexp(constant2));
}
function zoom(domain, anchor, scale, lift, ground) {
  const d0 = lift(domain[0]), d1 = lift(peek(domain)), da = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da + (d0 - da) * scale), ground(da + (d1 - da) * scale)];
}
function zoomLinear(domain, anchor, scale) {
  return zoom(domain, anchor, scale, toNumber, identity);
}
function zoomLog(domain, anchor, scale) {
  const sign = Math.sign(domain[0]);
  return zoom(domain, anchor, scale, log(sign), exp(sign));
}
function zoomPow(domain, anchor, scale, exponent) {
  return zoom(domain, anchor, scale, pow(exponent), pow(1 / exponent));
}
function zoomSymlog(domain, anchor, scale, constant2) {
  return zoom(domain, anchor, scale, symlog(constant2), symexp(constant2));
}
function quarter(date) {
  return 1 + ~~(new Date(date).getMonth() / 3);
}
function utcquarter(date) {
  return 1 + ~~(new Date(date).getUTCMonth() / 3);
}
function array(_) {
  return _ != null ? isArray(_) ? _ : [_] : [];
}
function clampRange(range, min, max) {
  let lo = range[0], hi = range[1], span2;
  if (hi < lo) {
    span2 = hi;
    hi = lo;
    lo = span2;
  }
  span2 = hi - lo;
  return span2 >= max - min ? [min, max] : [lo = Math.min(Math.max(lo, min), max - span2), lo + span2];
}
function isFunction(_) {
  return typeof _ === "function";
}
var DESCENDING = "descending";
function compare(fields, orders, opt) {
  opt = opt || {};
  orders = array(orders) || [];
  const ord = [], get = [], fmap = {}, gen = opt.comparator || comparator;
  array(fields).forEach((f, i) => {
    if (f == null)
      return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get.push(f = isFunction(f) ? f : field(f, null, opt));
    (accessorFields(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get.length === 0 ? null : accessor(gen(get, ord), Object.keys(fmap));
}
var ascending = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;
var comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
var compare1 = (field2, order) => function(a, b) {
  return ascending(field2(a), field2(b)) * order;
};
var compareN = (fields, orders, n) => {
  orders.push(0);
  return function(a, b) {
    let f, c = 0, i = -1;
    while (c === 0 && ++i < n) {
      f = fields[i];
      c = ascending(f(a), f(b));
    }
    return c * orders[i];
  };
};
function constant(_) {
  return isFunction(_) ? _ : () => _;
}
function debounce(delay, handler) {
  let tid;
  return (e) => {
    if (tid)
      clearTimeout(tid);
    tid = setTimeout(() => (handler(e), tid = null), delay);
  };
}
function extend(_) {
  for (let x, k, i = 1, len = arguments.length; i < len; ++i) {
    x = arguments[i];
    for (k in x) {
      _[k] = x[k];
    }
  }
  return _;
}
function extent(array2, f) {
  let i = 0, n, v, min, max;
  if (array2 && (n = array2.length)) {
    if (f == null) {
      for (v = array2[i]; i < n && (v == null || v !== v); v = array2[++i])
        ;
      min = max = v;
      for (; i < n; ++i) {
        v = array2[i];
        if (v != null) {
          if (v < min)
            min = v;
          if (v > max)
            max = v;
        }
      }
    } else {
      for (v = f(array2[i]); i < n && (v == null || v !== v); v = f(array2[++i]))
        ;
      min = max = v;
      for (; i < n; ++i) {
        v = f(array2[i]);
        if (v != null) {
          if (v < min)
            min = v;
          if (v > max)
            max = v;
        }
      }
    }
  }
  return [min, max];
}
function extentIndex(array2, f) {
  const n = array2.length;
  let i = -1, a, b, c, u, v;
  if (f == null) {
    while (++i < n) {
      b = array2[i];
      if (b != null && b >= b) {
        a = c = b;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u = v = i;
    while (++i < n) {
      b = array2[i];
      if (b != null) {
        if (a > b) {
          a = b;
          u = i;
        }
        if (c < b) {
          c = b;
          v = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b = f(array2[i], i, array2);
      if (b != null && b >= b) {
        a = c = b;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u = v = i;
    while (++i < n) {
      b = f(array2[i], i, array2);
      if (b != null) {
        if (a > b) {
          a = b;
          u = i;
        }
        if (c < b) {
          c = b;
          v = i;
        }
      }
    }
  }
  return [u, v];
}
var hop = Object.prototype.hasOwnProperty;
function has(object, property) {
  return hop.call(object, property);
}
var NULL = {};
function fastmap(input) {
  let obj = {}, test;
  function has$1(key2) {
    return has(obj, key2) && obj[key2] !== NULL;
  }
  const map = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key2) {
      return has$1(key2) ? obj[key2] : void 0;
    },
    set(key2, value) {
      if (!has$1(key2)) {
        ++map.size;
        if (obj[key2] === NULL)
          --map.empty;
      }
      obj[key2] = value;
      return this;
    },
    delete(key2) {
      if (has$1(key2)) {
        --map.size;
        ++map.empty;
        obj[key2] = NULL;
      }
      return this;
    },
    clear() {
      map.size = map.empty = 0;
      map.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test = _;
        return map;
      } else {
        return test;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key2 in obj) {
        const value = obj[key2];
        if (value !== NULL && (!test || !test(value))) {
          next[key2] = value;
          ++size;
        }
      }
      map.size = size;
      map.empty = 0;
      map.object = obj = next;
    }
  };
  if (input)
    Object.keys(input).forEach((key2) => {
      map.set(key2, input[key2]);
    });
  return map;
}
function flush(range, value, threshold, left, right, center) {
  if (!threshold && threshold !== 0)
    return center;
  const t = +threshold;
  let a = range[0], b = peek(range), l;
  if (b < a) {
    l = a;
    a = b;
    b = l;
  }
  l = Math.abs(value - a);
  const r = Math.abs(b - value);
  return l < r && l <= t ? left : r <= t ? right : center;
}
function inherits(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend(proto, members);
}
function inrange(value, range, left, right) {
  let r0 = range[0], r1 = range[range.length - 1], t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value : r0 < value) && (right ? value <= r1 : value < r1);
}
function isBoolean(_) {
  return typeof _ === "boolean";
}
function isDate(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable(_) {
  return _ && isFunction(_[Symbol.iterator]);
}
function isNumber(_) {
  return typeof _ === "number";
}
function isRegExp(_) {
  return Object.prototype.toString.call(_) === "[object RegExp]";
}
function isString(_) {
  return typeof _ === "string";
}
function key(fields, flat, opt) {
  if (fields) {
    fields = flat ? array(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter, map = (f) => gen(flat ? [f] : splitAccessPath(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get = map(fields[0]);
    fn = function(_) {
      return "" + get(_);
    };
  } else {
    const get = fields.map(map);
    fn = function(_) {
      let s = "" + get[0](_), i = 0;
      while (++i < len)
        s += "|" + get[i](_);
      return s;
    };
  }
  return accessor(fn, fields, "key");
}
function lerp(array2, frac) {
  const lo = array2[0], hi = peek(array2), f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}
var DEFAULT_MAX_SIZE = 1e4;
function lruCache(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev, size;
  const clear = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update = (key2, value) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key2] = value;
  };
  clear();
  return {
    clear,
    has: (key2) => has(curr, key2) || has(prev, key2),
    get: (key2) => has(curr, key2) ? curr[key2] : has(prev, key2) ? update(key2, prev[key2]) : void 0,
    set: (key2, value) => has(curr, key2) ? curr[key2] = value : update(key2, value)
  };
}
function merge(compare2, array0, array1, output) {
  const n0 = array0.length, n1 = array1.length;
  if (!n1)
    return array0;
  if (!n0)
    return array1;
  const merged = output || new array0.constructor(n0 + n1);
  let i0 = 0, i1 = 0, i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare2(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}
function repeat(str, reps) {
  let s = "";
  while (--reps >= 0)
    s += str;
  return s;
}
function pad(str, length, padchar, align) {
  const c = padchar || " ", s = str + "", n = length - s.length;
  return n <= 0 ? s : align === "left" ? repeat(c, n) + s : align === "center" ? repeat(c, ~~(n / 2)) + s + repeat(c, Math.ceil(n / 2)) : s + repeat(c, n);
}
function span(array2) {
  return array2 && peek(array2) - array2[0] || 0;
}
function $(x) {
  return isArray(x) ? "[" + x.map($) + "]" : isObject(x) || isString(x) ? JSON.stringify(x).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : x;
}
function toBoolean(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
var defaultParser = (_) => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);
function toDate(_, parser) {
  parser = parser || defaultParser;
  return _ == null || _ === "" ? null : parser(_);
}
function toString(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet(_) {
  const s = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s[_[i]] = true;
  return s;
}
function truncate(str, length, align, ellipsis) {
  const e = ellipsis != null ? ellipsis : "\u2026", s = str + "", n = s.length, l = Math.max(0, length - e.length);
  return n <= length ? s : align === "left" ? e + s.slice(n - l) : align === "center" ? s.slice(0, Math.ceil(l / 2)) + e + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e;
}
function visitArray(array2, filter, visitor) {
  if (array2) {
    if (filter) {
      const n = array2.length;
      for (let i = 0; i < n; ++i) {
        const t = filter(array2[i]);
        if (t)
          visitor(t, i, array2);
      }
    } else {
      array2.forEach(visitor);
    }
  }
}

// node_modules/vega-lite/build/src/logical.js
function isLogicalOr(op) {
  return !!op.or;
}
function isLogicalAnd(op) {
  return !!op.and;
}
function isLogicalNot(op) {
  return !!op.not;
}
function forEachLeaf(op, fn) {
  if (isLogicalNot(op)) {
    forEachLeaf(op.not, fn);
  } else if (isLogicalAnd(op)) {
    for (const subop of op.and) {
      forEachLeaf(subop, fn);
    }
  } else if (isLogicalOr(op)) {
    for (const subop of op.or) {
      forEachLeaf(subop, fn);
    }
  } else {
    fn(op);
  }
}
function normalizeLogicalComposition(op, normalizer) {
  if (isLogicalNot(op)) {
    return { not: normalizeLogicalComposition(op.not, normalizer) };
  } else if (isLogicalAnd(op)) {
    return { and: op.and.map((o) => normalizeLogicalComposition(o, normalizer)) };
  } else if (isLogicalOr(op)) {
    return { or: op.or.map((o) => normalizeLogicalComposition(o, normalizer)) };
  } else {
    return normalizer(op);
  }
}

// node_modules/vega-lite/build/src/util.js
var deepEqual = import_fast_deep_equal.default;
var duplicate = import_clone.default;
function never(message) {
  throw new Error(message);
}
function pick(obj, props) {
  const copy = {};
  for (const prop of props) {
    if (has(obj, prop)) {
      copy[prop] = obj[prop];
    }
  }
  return copy;
}
function omit(obj, props) {
  const copy = Object.assign({}, obj);
  for (const prop of props) {
    delete copy[prop];
  }
  return copy;
}
Set.prototype["toJSON"] = function() {
  return `Set(${[...this].map((x) => (0, import_fast_json_stable_stringify.default)(x)).join(",")})`;
};
var stringify = import_fast_json_stable_stringify.default;
function hash(a) {
  if (isNumber(a)) {
    return a;
  }
  const str = isString(a) ? a : (0, import_fast_json_stable_stringify.default)(a);
  if (str.length < 250) {
    return str;
  }
  let h = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    h = (h << 5) - h + char;
    h = h & h;
  }
  return h;
}
function isNullOrFalse(x) {
  return x === false || x === null;
}
function contains(array2, item) {
  return array2.includes(item);
}
function some(arr, f) {
  let i = 0;
  for (const [k, a] of arr.entries()) {
    if (f(a, k, i++)) {
      return true;
    }
  }
  return false;
}
function every(arr, f) {
  let i = 0;
  for (const [k, a] of arr.entries()) {
    if (!f(a, k, i++)) {
      return false;
    }
  }
  return true;
}
function mergeDeep(dest, ...src) {
  for (const s of src) {
    deepMerge_(dest, s !== null && s !== void 0 ? s : {});
  }
  return dest;
}
function deepMerge_(dest, src) {
  for (const property of keys(src)) {
    writeConfig(dest, property, src[property], true);
  }
}
function unique(values, f) {
  const results = [];
  const u = {};
  let v;
  for (const val of values) {
    v = f(val);
    if (v in u) {
      continue;
    }
    u[v] = 1;
    results.push(val);
  }
  return results;
}
function isEqual(dict, other) {
  const dictKeys = keys(dict);
  const otherKeys = keys(other);
  if (dictKeys.length !== otherKeys.length) {
    return false;
  }
  for (const key2 of dictKeys) {
    if (dict[key2] !== other[key2]) {
      return false;
    }
  }
  return true;
}
function setEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const e of a) {
    if (!b.has(e)) {
      return false;
    }
  }
  return true;
}
function hasIntersection(a, b) {
  for (const key2 of a) {
    if (b.has(key2)) {
      return true;
    }
  }
  return false;
}
function prefixGenerator(a) {
  const prefixes = /* @__PURE__ */ new Set();
  for (const x of a) {
    const splitField = splitAccessPath(x);
    const wrappedWithAccessors = splitField.map((y, i) => i === 0 ? y : `[${y}]`);
    const computedPrefixes = wrappedWithAccessors.map((_, i) => wrappedWithAccessors.slice(0, i + 1).join(""));
    for (const y of computedPrefixes) {
      prefixes.add(y);
    }
  }
  return prefixes;
}
function fieldIntersection(a, b) {
  if (a === void 0 || b === void 0) {
    return true;
  }
  return hasIntersection(prefixGenerator(a), prefixGenerator(b));
}
function isEmpty(obj) {
  return keys(obj).length === 0;
}
var keys = Object.keys;
var vals = Object.values;
var entries = Object.entries;
function isBoolean2(b) {
  return b === true || b === false;
}
function varName(s) {
  const alphanumericS = s.replace(/\W/g, "_");
  return (s.match(/^\d+/) ? "_" : "") + alphanumericS;
}
function logicalExpr(op, cb) {
  if (isLogicalNot(op)) {
    return `!(${logicalExpr(op.not, cb)})`;
  } else if (isLogicalAnd(op)) {
    return `(${op.and.map((and) => logicalExpr(and, cb)).join(") && (")})`;
  } else if (isLogicalOr(op)) {
    return `(${op.or.map((or) => logicalExpr(or, cb)).join(") || (")})`;
  } else {
    return cb(op);
  }
}
function deleteNestedProperty(obj, orderedProps) {
  if (orderedProps.length === 0) {
    return true;
  }
  const prop = orderedProps.shift();
  if (prop in obj && deleteNestedProperty(obj[prop], orderedProps)) {
    delete obj[prop];
  }
  return isEmpty(obj);
}
function titleCase(s) {
  return s.charAt(0).toUpperCase() + s.substr(1);
}
function accessPathWithDatum(path, datum = "datum") {
  const pieces = splitAccessPath(path);
  const prefixes = [];
  for (let i = 1; i <= pieces.length; i++) {
    const prefix = `[${pieces.slice(0, i).map($).join("][")}]`;
    prefixes.push(`${datum}${prefix}`);
  }
  return prefixes.join(" && ");
}
function flatAccessWithDatum(path, datum = "datum") {
  return `${datum}[${$(splitAccessPath(path).join("."))}]`;
}
function escapePathAccess(string) {
  return string.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function replacePathInField(path) {
  return `${splitAccessPath(path).map(escapePathAccess).join("\\.")}`;
}
function replaceAll(string, find, replacement) {
  return string.replace(new RegExp(find.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), replacement);
}
function removePathFromField(path) {
  return `${splitAccessPath(path).join(".")}`;
}
function accessPathDepth(path) {
  if (!path) {
    return 0;
  }
  return splitAccessPath(path).length;
}
function getFirstDefined(...args) {
  for (const arg of args) {
    if (arg !== void 0) {
      return arg;
    }
  }
  return void 0;
}
var idCounter = 42;
function uniqueId(prefix) {
  const id2 = ++idCounter;
  return prefix ? String(prefix) + id2 : id2;
}
function resetIdCounter() {
  idCounter = 42;
}
function internalField(name) {
  return isInternalField(name) ? name : `__${name}`;
}
function isInternalField(name) {
  return name.startsWith("__");
}
function normalizeAngle(angle) {
  if (angle === void 0) {
    return void 0;
  }
  return (angle % 360 + 360) % 360;
}
function isNumeric(value) {
  if (isNumber(value)) {
    return true;
  }
  return !isNaN(value) && !isNaN(parseFloat(value));
}

// node_modules/vega-lite/build/src/mark.js
var Mark = {
  arc: "arc",
  area: "area",
  bar: "bar",
  image: "image",
  line: "line",
  point: "point",
  rect: "rect",
  rule: "rule",
  text: "text",
  tick: "tick",
  trail: "trail",
  circle: "circle",
  square: "square",
  geoshape: "geoshape"
};
var ARC = Mark.arc;
var AREA = Mark.area;
var BAR = Mark.bar;
var IMAGE = Mark.image;
var LINE = Mark.line;
var POINT = Mark.point;
var RECT = Mark.rect;
var RULE = Mark.rule;
var TEXT = Mark.text;
var TICK = Mark.tick;
var TRAIL = Mark.trail;
var CIRCLE = Mark.circle;
var SQUARE = Mark.square;
var GEOSHAPE = Mark.geoshape;
function isMark(m) {
  return m in Mark;
}
function isPathMark(m) {
  return ["line", "area", "trail"].includes(m);
}
function isRectBasedMark(m) {
  return ["rect", "bar", "image", "arc"].includes(m);
}
var PRIMITIVE_MARKS = new Set(keys(Mark));
function isMarkDef(mark) {
  return mark["type"];
}
function isPrimitiveMark(mark) {
  const markType = isMarkDef(mark) ? mark.type : mark;
  return PRIMITIVE_MARKS.has(markType);
}
var STROKE_CONFIG = [
  "stroke",
  "strokeWidth",
  "strokeDash",
  "strokeDashOffset",
  "strokeOpacity",
  "strokeJoin",
  "strokeMiterLimit"
];
var FILL_CONFIG = ["fill", "fillOpacity"];
var FILL_STROKE_CONFIG = [...STROKE_CONFIG, ...FILL_CONFIG];
var VL_ONLY_MARK_CONFIG_INDEX = {
  color: 1,
  filled: 1,
  invalid: 1,
  order: 1,
  radius2: 1,
  theta2: 1,
  timeUnitBandSize: 1,
  timeUnitBandPosition: 1
};
var VL_ONLY_MARK_CONFIG_PROPERTIES = keys(VL_ONLY_MARK_CONFIG_INDEX);
var VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
  area: ["line", "point"],
  bar: ["binSpacing", "continuousBandSize", "discreteBandSize"],
  rect: ["binSpacing", "continuousBandSize", "discreteBandSize"],
  line: ["point"],
  tick: ["bandSize", "thickness"]
};
var defaultMarkConfig = {
  color: "#4c78a8",
  invalid: "filter",
  timeUnitBandSize: 1
};
var MARK_CONFIG_INDEX = {
  mark: 1,
  arc: 1,
  area: 1,
  bar: 1,
  circle: 1,
  image: 1,
  line: 1,
  point: 1,
  rect: 1,
  rule: 1,
  square: 1,
  text: 1,
  tick: 1,
  trail: 1,
  geoshape: 1
};
var MARK_CONFIGS = keys(MARK_CONFIG_INDEX);
function isRelativeBandSize(o) {
  return o && o["band"] != void 0;
}
var BAR_CORNER_RADIUS_INDEX = {
  horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
  vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
};
var DEFAULT_RECT_BAND_SIZE = 5;
var defaultBarConfig = {
  binSpacing: 1,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  timeUnitBandPosition: 0.5
};
var defaultRectConfig = {
  binSpacing: 0,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  timeUnitBandPosition: 0.5
};
var defaultTickConfig = {
  thickness: 1
};
function getMarkType(m) {
  return isMarkDef(m) ? m.type : m;
}

export {
  __commonJS,
  __export,
  __toESM,
  accessor,
  accessorName,
  accessorFields,
  error,
  splitAccessPath,
  field,
  id,
  identity,
  zero,
  one,
  truthy,
  falsy,
  None,
  Error$1,
  Warn,
  Info,
  Debug,
  logger,
  isArray,
  isObject,
  mergeConfig,
  writeConfig,
  peek,
  toNumber,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog,
  quarter,
  utcquarter,
  array,
  clampRange,
  isFunction,
  compare,
  ascending,
  constant,
  debounce,
  extend,
  extent,
  extentIndex,
  has,
  fastmap,
  flush,
  inherits,
  inrange,
  isBoolean,
  isDate,
  isIterable,
  isNumber,
  isRegExp,
  isString,
  key,
  lerp,
  lruCache,
  merge,
  repeat,
  pad,
  span,
  $,
  toBoolean,
  toDate,
  toString,
  toSet,
  truncate,
  visitArray,
  forEachLeaf,
  normalizeLogicalComposition,
  deepEqual,
  duplicate,
  never,
  pick,
  omit,
  stringify,
  hash,
  isNullOrFalse,
  contains,
  some,
  every,
  mergeDeep,
  unique,
  isEqual,
  setEqual,
  hasIntersection,
  prefixGenerator,
  fieldIntersection,
  isEmpty,
  keys,
  vals,
  entries,
  isBoolean2,
  varName,
  logicalExpr,
  deleteNestedProperty,
  titleCase,
  accessPathWithDatum,
  flatAccessWithDatum,
  replacePathInField,
  replaceAll,
  removePathFromField,
  accessPathDepth,
  getFirstDefined,
  uniqueId,
  resetIdCounter,
  internalField,
  isInternalField,
  normalizeAngle,
  isNumeric,
  Mark,
  ARC,
  AREA,
  BAR,
  IMAGE,
  LINE,
  POINT,
  RECT,
  RULE,
  TEXT,
  TICK,
  TRAIL,
  CIRCLE,
  SQUARE,
  GEOSHAPE,
  isMark,
  isPathMark,
  isRectBasedMark,
  PRIMITIVE_MARKS,
  isMarkDef,
  isPrimitiveMark,
  STROKE_CONFIG,
  FILL_CONFIG,
  FILL_STROKE_CONFIG,
  VL_ONLY_MARK_CONFIG_PROPERTIES,
  VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX,
  defaultMarkConfig,
  MARK_CONFIGS,
  isRelativeBandSize,
  BAR_CORNER_RADIUS_INDEX,
  defaultBarConfig,
  defaultRectConfig,
  defaultTickConfig,
  getMarkType
};
//# sourceMappingURL=chunk-JANSOTZD.js.map
